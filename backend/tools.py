"""
Tool Use System for Anthropic Claude Integration

Provides:
- ToolDefinition: Define tools with JSON Schema
- ToolRegistry: Register and execute tools
- ToolCall/ToolResult: Data structures for tool execution
"""

from dataclasses import dataclass, field
from typing import Optional, Dict, Any, List, Callable, Awaitable, Union
from enum import Enum


class ToolCategory(Enum):
    """Categories of tools for organization"""
    CODE_EXECUTION = "code_execution"
    DOCUMENT_ACCESS = "document_access"
    STUDENT_DATA = "student_data"
    GRADING = "grading"
    SEARCH = "search"


@dataclass
class ToolParameter:
    """Definition of a tool parameter"""
    name: str
    type: str  # "string", "integer", "number", "boolean", "array", "object"
    description: str
    required: bool = True
    enum: Optional[List[str]] = None
    default: Optional[Any] = None
    items: Optional[Dict[str, str]] = None  # For array types

    def to_json_schema(self) -> Dict[str, Any]:
        """Convert to JSON Schema format"""
        schema: Dict[str, Any] = {
            "type": self.type,
            "description": self.description
        }
        if self.enum:
            schema["enum"] = self.enum
        if self.items and self.type == "array":
            schema["items"] = self.items
        if self.default is not None:
            schema["default"] = self.default
        return schema


@dataclass
class ToolDefinition:
    """Complete definition of a tool for Anthropic API"""
    name: str
    description: str
    parameters: List[ToolParameter]
    handler: Optional[Callable[..., Awaitable[Any]]] = None
    category: ToolCategory = ToolCategory.CODE_EXECUTION

    # Execution constraints
    max_execution_time_ms: int = 30000

    def to_anthropic_format(self) -> Dict[str, Any]:
        """Convert to Anthropic API tool format"""
        properties = {}
        required = []

        for param in self.parameters:
            properties[param.name] = param.to_json_schema()
            if param.required:
                required.append(param.name)

        return {
            "name": self.name,
            "description": self.description,
            "input_schema": {
                "type": "object",
                "properties": properties,
                "required": required
            }
        }


@dataclass
class ToolCall:
    """Represents a tool call from Claude"""
    id: str
    name: str
    input: Dict[str, Any]


@dataclass
class ToolResult:
    """Result of executing a tool"""
    tool_use_id: str
    content: Union[str, List[Dict[str, Any]]]
    is_error: bool = False

    # Optional: files generated by the tool
    files_generated: List[Dict[str, Any]] = field(default_factory=list)

    def to_anthropic_format(self) -> Dict[str, Any]:
        """Convert to Anthropic API tool_result format"""
        return {
            "type": "tool_result",
            "tool_use_id": self.tool_use_id,
            "content": self.content,
            "is_error": self.is_error
        }


@dataclass
class ToolExecutionContext:
    """Context passed to tool handlers"""
    atividade_id: Optional[str] = None
    aluno_id: Optional[str] = None
    session_id: Optional[str] = None
    user_id: Optional[str] = None


class ToolRegistry:
    """Registry for managing and executing tools"""

    def __init__(self):
        self.tools: Dict[str, ToolDefinition] = {}

    def register(self, tool: ToolDefinition) -> None:
        """Register a tool"""
        self.tools[tool.name] = tool

    def unregister(self, name: str) -> bool:
        """Unregister a tool"""
        if name in self.tools:
            del self.tools[name]
            return True
        return False

    def get(self, name: str) -> Optional[ToolDefinition]:
        """Get a tool by name"""
        return self.tools.get(name)

    def list_tools(self) -> List[str]:
        """List all registered tool names"""
        return list(self.tools.keys())

    def get_anthropic_tools(self, tool_names: Optional[List[str]] = None) -> List[Dict[str, Any]]:
        """Get tools in Anthropic API format"""
        if tool_names is None:
            return [t.to_anthropic_format() for t in self.tools.values()]
        return [
            self.tools[name].to_anthropic_format()
            for name in tool_names
            if name in self.tools
        ]

    async def execute(
        self,
        tool_name: str,
        tool_input: Dict[str, Any],
        tool_use_id: str,
        context: Optional[ToolExecutionContext] = None
    ) -> ToolResult:
        """Execute a tool and return the result"""
        tool = self.tools.get(tool_name)

        if not tool:
            return ToolResult(
                tool_use_id=tool_use_id,
                content=f"Unknown tool: {tool_name}",
                is_error=True
            )

        if not tool.handler:
            return ToolResult(
                tool_use_id=tool_use_id,
                content=f"Tool '{tool_name}' has no handler configured",
                is_error=True
            )

        try:
            result = await tool.handler(tool_input, context)

            # Handle different return types
            if isinstance(result, ToolResult):
                result.tool_use_id = tool_use_id
                return result
            elif isinstance(result, str):
                return ToolResult(
                    tool_use_id=tool_use_id,
                    content=result,
                    is_error=False
                )
            elif isinstance(result, dict):
                return ToolResult(
                    tool_use_id=tool_use_id,
                    content=result.get("content", str(result)),
                    is_error=result.get("is_error", False),
                    files_generated=result.get("files_generated", [])
                )
            else:
                return ToolResult(
                    tool_use_id=tool_use_id,
                    content=str(result),
                    is_error=False
                )

        except Exception as e:
            return ToolResult(
                tool_use_id=tool_use_id,
                content=f"Tool execution error: {str(e)}",
                is_error=True
            )


# =============================================================================
# Pre-defined Tool Definitions for Educational Platform
# =============================================================================

EXECUTE_PYTHON_CODE = ToolDefinition(
    name="execute_python_code",
    description="""Execute Python code in a secure sandbox. Use this to:
- Generate Excel files (pandas, openpyxl)
- Create PDF reports (reportlab)
- Generate charts and visualizations (matplotlib)
- Process data and calculations
- Create text files and CSVs

The code runs in isolation with these allowed libraries:
pandas, numpy, matplotlib, openpyxl, reportlab, Pillow, scipy

Important: Always save outputs to files (e.g., 'output.xlsx', 'chart.png').""",
    parameters=[
        ToolParameter(
            name="code",
            type="string",
            description="Python code to execute. Must use allowed libraries only."
        ),
        ToolParameter(
            name="output_files",
            type="array",
            description="List of filenames the code will generate (e.g., ['report.xlsx', 'chart.png'])",
            required=False,
            items={"type": "string"}
        ),
        ToolParameter(
            name="description",
            type="string",
            description="Brief description of what the code does",
            required=False
        )
    ],
    category=ToolCategory.CODE_EXECUTION,
    max_execution_time_ms=60000
)


GET_DOCUMENT_CONTENT = ToolDefinition(
    name="get_document_content",
    description="""Retrieve content from documents in the system. Use this to:
- Read exam questions (enunciado)
- Access answer keys (gabarito)
- View student responses (prova_respondida)
- Check previous corrections and analyses

You must provide at least document_id OR (document_type + atividade_id).""",
    parameters=[
        ToolParameter(
            name="document_id",
            type="string",
            description="ID of the document to retrieve",
            required=False
        ),
        ToolParameter(
            name="document_type",
            type="string",
            description="Type of document to search for",
            enum=["enunciado", "gabarito", "prova_respondida", "correcao",
                  "extracao_questoes", "extracao_respostas", "analise_habilidades"],
            required=False
        ),
        ToolParameter(
            name="atividade_id",
            type="string",
            description="Activity ID to scope the search",
            required=False
        ),
        ToolParameter(
            name="aluno_id",
            type="string",
            description="Student ID to scope the search",
            required=False
        )
    ],
    category=ToolCategory.DOCUMENT_ACCESS
)


GET_STUDENT_INFO = ToolDefinition(
    name="get_student_info",
    description="""Retrieve information about a student including:
- Name and basic info
- Class/group assignment
- List of submitted assignments
- Historical grades (if include_grades=true)""",
    parameters=[
        ToolParameter(
            name="aluno_id",
            type="string",
            description="Student ID to look up"
        ),
        ToolParameter(
            name="include_grades",
            type="boolean",
            description="Whether to include grade history",
            required=False,
            default=True
        )
    ],
    category=ToolCategory.STUDENT_DATA
)


SEARCH_DOCUMENTS = ToolDefinition(
    name="search_documents",
    description="""Search for documents by text content or metadata.
Useful for finding related questions, past exams, or specific content.""",
    parameters=[
        ToolParameter(
            name="query",
            type="string",
            description="Search query text"
        ),
        ToolParameter(
            name="document_type",
            type="string",
            description="Filter by document type",
            enum=["enunciado", "gabarito", "prova_respondida", "correcao", "all"],
            required=False
        ),
        ToolParameter(
            name="limit",
            type="integer",
            description="Maximum number of results (1-20)",
            required=False,
            default=5
        )
    ],
    category=ToolCategory.SEARCH
)


SAVE_CORRECTION = ToolDefinition(
    name="save_correction",
    description="""Save correction results for a student's response. Use after grading to persist:
- Score given
- Feedback text
- Identified errors

This permanently saves the correction to the database.""",
    parameters=[
        ToolParameter(
            name="questao_id",
            type="string",
            description="ID of the question being graded"
        ),
        ToolParameter(
            name="aluno_id",
            type="string",
            description="ID of the student"
        ),
        ToolParameter(
            name="nota",
            type="number",
            description="Score given (0 to nota_maxima)"
        ),
        ToolParameter(
            name="nota_maxima",
            type="number",
            description="Maximum possible score"
        ),
        ToolParameter(
            name="feedback",
            type="string",
            description="Detailed feedback for the student"
        ),
        ToolParameter(
            name="erros",
            type="array",
            description="List of identified errors",
            required=False,
            items={"type": "string"}
        )
    ],
    category=ToolCategory.GRADING
)


CREATE_DOCUMENT = ToolDefinition(
    name="create_document",
    description="""Create and save one or more documents to the system. Use this tool to:
- Create report files (PDF, DOCX, TXT, MD)
- Generate student feedback documents
- Create analysis summaries
- Save any structured document

This tool can create MULTIPLE documents in a single call. Each document will be saved
with proper metadata and can be associated with a student (aluno_id) and/or activity (atividade_id).

The documents array can contain multiple items - use this when you need to create
several related documents at once (e.g., individual reports for each student).""",
    parameters=[
        ToolParameter(
            name="documents",
            type="array",
            description="Array of documents to create. Each document should have: filename, content, and optionally document_type and description.",
            items={
                "type": "object",
                "properties": {
                    "filename": {"type": "string", "description": "Name of the file to create (e.g., 'report.pdf', 'feedback.docx')"},
                    "content": {"type": "string", "description": "Content of the document"},
                    "document_type": {"type": "string", "description": "Type: 'report', 'feedback', 'analysis', 'summary', 'other'"},
                    "description": {"type": "string", "description": "Brief description of this document"}
                },
                "required": ["filename", "content"]
            }
        ),
        ToolParameter(
            name="aluno_id",
            type="string",
            description="Student ID to associate documents with (optional)",
            required=False
        ),
        ToolParameter(
            name="atividade_id",
            type="string",
            description="Activity ID to associate documents with (optional)",
            required=False
        ),
        ToolParameter(
            name="turma_id",
            type="string",
            description="Class ID when creating documents for an entire class (optional)",
            required=False
        )
    ],
    category=ToolCategory.DOCUMENT_ACCESS
)


# Default tools for general chat (code execution only)
DEFAULT_CHAT_TOOLS = [EXECUTE_PYTHON_CODE]

# Tools for pipeline (correction, analysis, document creation)
PIPELINE_TOOLS = [
    EXECUTE_PYTHON_CODE,
    GET_DOCUMENT_CONTENT,
    GET_STUDENT_INFO,
    SEARCH_DOCUMENTS,
    SAVE_CORRECTION,
    CREATE_DOCUMENT
]

# All available tools
ALL_TOOLS = [
    EXECUTE_PYTHON_CODE,
    GET_DOCUMENT_CONTENT,
    GET_STUDENT_INFO,
    SEARCH_DOCUMENTS,
    SAVE_CORRECTION,
    CREATE_DOCUMENT
]


def create_default_registry() -> ToolRegistry:
    """Create a registry with default tools (handlers must be set separately)"""
    registry = ToolRegistry()
    for tool in DEFAULT_CHAT_TOOLS:
        registry.register(tool)
    return registry


def create_full_registry() -> ToolRegistry:
    """Create a registry with all tools (handlers must be set separately)"""
    registry = ToolRegistry()
    for tool in ALL_TOOLS:
        registry.register(tool)
    return registry


def create_registry_with_handlers(tool_names: Optional[List[str]] = None) -> ToolRegistry:
    """
    Create a registry with tools and their handlers connected.

    Args:
        tool_names: List of tool names to include. If None, includes DEFAULT_CHAT_TOOLS.

    Returns:
        ToolRegistry with handlers connected.
    """
    from tool_handlers import TOOL_HANDLERS

    registry = ToolRegistry()

    # Determine which tools to include
    if tool_names is None:
        tools_to_register = DEFAULT_CHAT_TOOLS
    else:
        tools_to_register = [t for t in ALL_TOOLS if t.name in tool_names]

    # Register tools with handlers
    for tool in tools_to_register:
        handler = TOOL_HANDLERS.get(tool.name)
        if handler:
            tool.handler = handler
        registry.register(tool)

    return registry
