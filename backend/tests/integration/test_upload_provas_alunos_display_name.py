"""
Integration tests for F3-T4: /api/documentos/upload-provas-alunos auto-generates
structured display_names that include document type, student name, materia,
and turma â€” forwarded through storage.salvar_documento().

These tests verify that the display_name visible on saved documents:
  1. Contains a human-readable label for the document type (e.g. "Prova Respondida").
  2. Contains the student name.
  3. Contains the materia and turma names.

F3-T1 already added display_name auto-generation to salvar_documento(), so these
tests MAY pass depending on whether build_display_name() is wired up correctly for
the prova_alunos endpoint.  Writing them now pins the expected contract so any
regression is immediately caught.

Plan: docs/PLAN_File_Naming_Document_Tracking.md  (F3-T4)
"""
import sys
import os
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..'))

import pytest
from fastapi.testclient import TestClient


# ============================================================
# F3-T4 Tests
# ============================================================

class TestUploadProvasAlunosDisplayName:
    """
    /api/documentos/upload-provas-alunos must save documents whose
    display_name is auto-generated by build_display_name() and therefore
    includes the document type label, student name, materia, and turma.
    """

    @pytest.fixture(autouse=True)
    def setup(self, monkeypatch, temp_data_dir):
        """Set up isolated SQLite-backed storage and TestClient for each test.

        Patches both Supabase flags to False BEFORE constructing StorageManager
        so the instance uses SQLite rather than the live Supabase instance.
        """
        monkeypatch.setattr("storage.SUPABASE_DB_AVAILABLE", False)
        monkeypatch.setattr("storage.SUPABASE_STORAGE_AVAILABLE", False)

        from storage import StorageManager
        self.storage = StorageManager(base_path=str(temp_data_dir))

        self.materia = self.storage.criar_materia(nome="Biologia")
        self.turma = self.storage.criar_turma(
            materia_id=self.materia.id, nome="Turma C"
        )
        self.atividade = self.storage.criar_atividade(
            turma_id=self.turma.id, nome="Prova Final"
        )
        # Student's matricula must appear in the uploaded filename for matching
        self.aluno = self.storage.criar_aluno(
            nome="Carlos Souza", matricula="2024001"
        )
        self.storage.vincular_aluno_turma(
            aluno_id=self.aluno.id, turma_id=self.turma.id
        )

        # Patch storage in both endpoint modules
        monkeypatch.setattr("main_v2.storage", self.storage)
        monkeypatch.setattr("routes_extras.storage", self.storage)

        from main_v2 import app
        self.client = TestClient(app)

    def test_provas_alunos_auto_generates_display_name(self):
        """
        POST /api/documentos/upload-provas-alunos with a file whose name contains
        the student's matricula must return a document with display_name that
        includes "Prova Respondida" (the human-readable type label) and the
        student's name ("Carlos Souza").

        This pins the auto-generation contract from F3-T1.
        If salvar_documento() generates display_name correctly the test passes.
        If display_name is empty or missing the human-readable parts, it fails.
        """
        # Filename contains matricula "2024001" so the endpoint matches Carlos Souza
        response = self.client.post(
            "/api/documentos/upload-provas-alunos",
            data={
                "atividade_id": self.atividade.id,
                "modo_nome": "matricula",
            },
            files=[
                (
                    "files",
                    ("2024001_prova.pdf", b"%PDF-1.4 prova content", "application/pdf"),
                )
            ],
        )

        assert response.status_code == 200, (
            f"Expected 200, got {response.status_code}: {response.text}"
        )
        data = response.json()

        assert data["salvos"] == 1, (
            f"Expected 1 saved document, got {data['salvos']}. "
            f"Errors: {data.get('detalhes_erros', [])}"
        )

        doc_entry = data["documentos"][0]
        # The endpoint returns {"documento": {...}, "aluno": nome}
        doc = doc_entry["documento"]

        assert "display_name" in doc, (
            "Documento dict must include 'display_name' key."
        )
        display = doc["display_name"]
        assert display, "display_name must not be empty."

        assert "Prova Respondida" in display, (
            f"display_name '{display}' must contain 'Prova Respondida' "
            "(the human-readable label for TipoDocumento.PROVA_RESPONDIDA). "
            "Check build_display_name() in storage.py and _TIPO_LABELS mapping."
        )
        assert "Carlos Souza" in display, (
            f"display_name '{display}' must contain the student name 'Carlos Souza'. "
            "salvar_documento() should resolve the aluno and include its name in "
            "the auto-generated display_name via build_display_name()."
        )

    def test_provas_alunos_display_name_includes_materia_turma(self):
        """
        The auto-generated display_name for an uploaded student exam must also
        include the materia name ("Biologia") and turma name ("Turma C").

        build_display_name() receives materia_nome and turma_nome so they
        appear in the output format:
            "Prova Respondida - Carlos Souza - Biologia - Turma C"

        If storage.salvar_documento() does not resolve turma/materia from the
        atividade hierarchy the names will be absent and this test will fail.
        """
        response = self.client.post(
            "/api/documentos/upload-provas-alunos",
            data={
                "atividade_id": self.atividade.id,
                "modo_nome": "matricula",
            },
            files=[
                (
                    "files",
                    ("2024001_prova.pdf", b"%PDF-1.4 content", "application/pdf"),
                )
            ],
        )

        assert response.status_code == 200, (
            f"Expected 200, got {response.status_code}: {response.text}"
        )
        data = response.json()

        assert data["salvos"] == 1, (
            f"Expected 1 saved document, got {data['salvos']}. "
            f"Errors: {data.get('detalhes_erros', [])}"
        )

        doc = data["documentos"][0]["documento"]
        display = doc.get("display_name", "")

        assert "Biologia" in display, (
            f"display_name '{display}' must contain the materia name 'Biologia'. "
            "salvar_documento() must resolve the materia from the atividade->turma "
            "chain and pass materia_nome to build_display_name()."
        )
        assert "Turma C" in display, (
            f"display_name '{display}' must contain the turma name 'Turma C'. "
            "salvar_documento() must resolve the turma and pass turma_nome to "
            "build_display_name()."
        )
